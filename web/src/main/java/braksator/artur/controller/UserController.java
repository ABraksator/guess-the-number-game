package braksator.artur.controller;

import braksator.artur.entity.User;
import braksator.artur.form.LoginForm;
import braksator.artur.repository.UserRepository;
import braksator.artur.util.AttributeNames;
import braksator.artur.util.GameMappings;
import braksator.artur.util.Test;
import braksator.artur.util.ViewNames;
import lombok.extern.slf4j.Slf4j;
import org.mindrot.jbcrypt.BCrypt;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.event.EventListener;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.validation.BindingResult;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.servlet.mvc.support.RedirectAttributes;

import javax.servlet.http.HttpSession;
import javax.validation.Valid;

@Slf4j
@Controller // This means that this class is a Controller
@RequestMapping(path = "/user") // This means URL's start with /demo (after Application path)
public class UserController {
    @Autowired // This means to get the bean called userRepository
    // Which is auto-generated by Spring, we will use it to handle the data
    private UserRepository userRepository;

    @PostMapping(path = "/add") // Map ONLY POST Requests
    public @ResponseBody
    String addNewUser(@RequestParam String userName, @RequestParam String password
            , @RequestParam String email) {
        // @ResponseBody means the returned String is the response, not a view userName
        // @RequestParam means it is a parameter from the GET or POST request

        User n = new User();
        n.setUserName(userName);
        n.setEmail(email);
        n.setPassword(password);
        userRepository.save(n);
        return "User Created";
    }

    @GetMapping(path = "/all")
    public @ResponseBody
    Iterable<User> getAllUsers() {
        // This returns a JSON or XML with the users
        return userRepository.findAll();
    }

    // tworzy automatycznie usera
    @EventListener(ApplicationReadyEvent.class)
    public void createAdmin() {
        User user = new User("Artur", BCrypt.hashpw("Braksator", BCrypt.gensalt()), "artur@gmail.com");
        userRepository.save(user);


    }

//Moje wersje ktore działał
//    @GetMapping(path = "login")
//    public String login(Model model, @ModelAttribute("message") String message) {
//        if (message.length() == 0) {
//            model.addAttribute("message", message);
//        }
//        return "login";
//    }

    @GetMapping(path = "login")
    public String login(Model model, @ModelAttribute("loginMessage") String loginMessage) {
//    public String login(Model model) {
        model.addAttribute("loginForm", new LoginForm());
        model.addAttribute("loginMessage", loginMessage);
        log.debug(" model.containsAttribute(loginMessage) ={}", model.containsAttribute("loginError"));
        return "login";
    }

    @PostMapping(path = "/login")
    public String processLoginRequest(@Valid LoginForm loginForm, BindingResult result, HttpSession session, RedirectAttributes atts) {

        if (result.hasErrors()) {
            atts.addAttribute("loginMessage", "Fill up the form, please");
            return "redirect:/user/login";
        }
        User user = userRepository.findByUserName(loginForm.getUserName());
        if (user != null && BCrypt.checkpw(loginForm.getPassword(), user.getPassword())) {
            session.setAttribute("user", user);
            return "redirect:/play";
        } else {
//            FieldError error = new FieldError("user", "password", "Sorry, Incorrect Login or password");
//            result.addError(error);
//            result.getModel().put("password", "");
            atts.addAttribute("loginMessage", "Sorry, Incorrect Login or password");
            return "redirect:/user/login";
        }
    }
//moje wersje
//    @PostMapping(path = "login")
//    public String login(@RequestParam String userName, @RequestParam String password, HttpSession session, RedirectAttributes atts) {
//
//        User user = userRepository.findByUserName(userName);
//        if (user != null && BCrypt.checkpw(password, user.getPassword())) {
//            session.setAttribute("user", user);
//            return GameMappings.REDIRECT_PLAY;
////            return "redirect:/" + ViewNames.PLAY;
//        } else {
////            FieldError error = new FieldError("user", "password", "Sorry, Incorrect Login or password");
////            result.addError(error);
////            result.getModel().put("password", "");
//            atts.addAttribute("message", "Sorry, Incorrect Login or password");
//            return "redirect:/user/login";
//        }
//    }


    @GetMapping(path = "register")
    public String register(Model model, @ModelAttribute("registerMessage") String message) {
        if (message.length() == 0) {
            model.addAttribute("message", message);
        }
        return "register";
    }

    @PostMapping(path = "register")
    public String register(@Valid User user, BindingResult result, HttpSession session, RedirectAttributes atts) {

        if (result.hasErrors()) {
            atts.addAttribute("registerMessage", "Fields are not filled up correctly.");
            return "redirect:/user/register";
        }
//        return "play";

//        User user = userRepository.findByUserName(user.getUserName());

        User existingUserByEmail = userRepository.findFirstByEmail(user.getEmail());
        User existingUserByName = userRepository.findByUserName(user.getUserName());
        if (existingUserByEmail != null || existingUserByName != null) {
//            FieldError error = new FieldError("user", "email", "Sorry, this e-mail is already signed up");
            atts.addAttribute("registerMessage", "Sorry, this user name or e-mail is already registered.");
//            bresult.addError(error);
            return "redirect:/user/register";
        } else {
            userRepository.save(user);
            atts.addAttribute("loginMessage", "Congratulation, your account has been successfully created. Pleas login");
            return "redirect:/user/login";
        }


//        if (user != null) {
//            atts.addAttribute("message", "That user already exist. Chose different User Name");
//            return "redirect:/user/register";
//
//        } else if (user != null && BCrypt.checkpw(password, user.getPassword())) {
//            session.setAttribute("user", user);
//            return GameMappings.REDIRECT_PLAY;
////            return "redirect:/" + ViewNames.PLAY;
//        } else {
////            FieldError error = new FieldError("user", "password", "Sorry, Incorrect Login or password");
////            result.addError(error);
////            result.getModel().put("password", "");
//            atts.addAttribute("message", "Sorry, Incorrect Login or password");
//            return "redirect:/user/register";
//        }
    }


    @GetMapping(path = "/logout")
    public String logout(HttpSession session) {
//        session.removeAttribute("user");
        session.invalidate();
        return "redirect:/";
    }


//
//    @GetMapping(path ="/test")
//    public String test(HttpSession session){
//        User user = (User) session.getAttribute("user");
//        if(user != null){
//            return "redirect:/play";
//        }
//        return "redirect:/";
//    }
    @GetMapping(path ="/test")
    public String test(HttpSession session){
        User user = (User) session.getAttribute("user");
        if(user != null){
            return "redirect:/play";
        }
        return "redirect:/";
    }

}


//    @GetMapping(GameMappings.PLAY)
//    public String play(Model model) {
//        model.addAttribute(AttributeNames.MAIN_MESSAGE, gameService.getMainMessage());
//        model.addAttribute(AttributeNames.RESULT_MESSAGE, gameService.getResultMessage());
//        log.info("model= {}", model);
//
//        if(gameService.isGameOver()) {
//            return ViewNames.GAME_OVER;
//        }
//
//        return ViewNames.PLAY;
//    }
